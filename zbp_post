mysql> desc zbp_post;
+--------------+--------------+------+-----+---------+----------------+
| Field        | Type         | Null | Key | Default | Extra          |
+--------------+--------------+------+-----+---------+----------------+
| log_ID       | int          | NO   | PRI | NULL    | auto_increment |
| log_CateID   | smallint     | NO   |     | 0       |                |
| log_AuthorID | int          | NO   |     | 0       |                |
| log_Tag      | varchar(255) | NO   |     |         |                |
| log_Status   | tinyint      | NO   |     | 0       |                |
| log_Type     | tinyint      | NO   | MUL | 0       |                |
| log_Alias    | varchar(255) | NO   |     |         |                |
| log_IsTop    | tinyint(1)   | NO   |     | 0       |                |
| log_IsLock   | tinyint(1)   | NO   |     | 0       |                |
| log_Title    | varchar(255) | NO   |     |         |                |
| log_Intro    | text         | NO   |     | NULL    |                |
| log_Content  | longtext     | NO   |     | NULL    |                |
| log_PostTime | int          | NO   |     | 0       |                |
| log_CommNums | int          | NO   |     | 0       |                |
| log_ViewNums | int          | NO   |     | 0       |                |
| log_Template | varchar(255) | NO   |     |         |                |
| log_Meta     | longtext     | NO   |     | NULL    |                |
+--------------+--------------+------+-----+---------+----------------+
17 rows in set (0.00 sec)

mysql> select * from zbp_post where log_ID = 524\G;
*************************** 1. row ***************************
      log_ID: 524
  log_CateID: 20
log_AuthorID: 1
     log_Tag: {77}{53}
  log_Status: 0
    log_Type: 0
   log_Alias: MongoDB之数据分片
   log_IsTop: 0
  log_IsLock: 0
   log_Title: MongoDB之数据分片
   log_Intro: 一、数据库分片的必要性
1、可扩展性
1.1 当数据库请求用户数量越来越多时，CPU负载会越来越高
1.2 当数据库中的数据越来越多时，I/O负载会越来越高
1.3 为了不影响数据库服务的响应速度以及服务本身的可靠性，扩展系统成为必然之选
2、两种扩展方式
2.1 纵向扩展
增强单一服务器的性能

简单的架构和运维模型
单一服务器性能总是有上限的

2.2 横向扩展
增加提供服务的服务器数量

更高的可扩展性
增加架构和运维的复杂度

3、数据库分片就属于一种<!--autointro-->
 log_Content: <h1>一、数据库分片的必要性</h1>
<h2>1、可扩展性</h2>
<h3>1.1 当数据库请求用户数量越来越多时，CPU负载会越来越高</h3>
<h3>1.2 当数据库中的数据越来越多时，I/O负载会越来越高</h3>
<h3>1.3 为了不影响数据库服务的响应速度以及服务本身的可靠性，扩展系统成为必然之选</h3>
<h2>2、两种扩展方式</h2>
<h3>2.1 纵向扩展</h3>
<p>增强单一服务器的性能</p>
<ul>
<li>简单的架构和运维模型</li>
<li>单一服务器性能总是有上限的</li>
</ul>
<h3>2.2 横向扩展</h3>
<p>增加提供服务的服务器数量</p>
<ul>
<li>更高的可扩展性</li>
<li>增加架构和运维的复杂度</li>
</ul>
<h2>3、数据库分片就属于一种横向扩展的方式</h2>
<h1>二、数据库分片</h1>
<h2>1、将数据库中的数据分成一个一个的子集</h2>
<h2>2、每个子集都存储在一个分片上</h2>
<p>分片可以部署为复制集</p>
<p>增加可用性和数据安全性</p>
<h2>3、所有分片合在一起构成一个分片集群</h2>
<h2>4、所有分片上的数据加在一起才是完整的数据</h2>
<h2>5、每个分片是可以跑在独立的服务器上的</h2>
<h1>三、构成分片集群的组件</h1>
<h2>1、配置服务器</h2>
<h3>1.1 元数据</h3>
<ul>
<li>存储各分片数据段列表和数据段范围</li>
<li>整个分片集群中分片的数量</li>
</ul>
<h3>1.2 配置信息</h3>
<p>存储集群的认证和授权配置</p>
<h3>1.3 不同的集群不要共用配置服务器</h3>
<h3>1.4 配置服务器也可以部署为复制集</h3>
<ul>
<li>增加可用性和数据安全性</li>
<li>主节点故障并且暂时无法上线新的主节点时，配置服务器会进入只读模式<p>只读模式下，数据段分裂和集群平衡都不可执行</p></li>
<li>整个复制集发生故障时，分片集群不可用</li>
</ul>
<h2>2、mongos</h2>
<h3>2.1 请求路由</h3>
<ul>
<li>将用户请求转发到对应的分片服务器</li>
<li>mongos会首先读取配置服务器元数据</li>
<li>客户请求应发给mongos，而不是分片服务器</li>
</ul>
<h3>2.2 可以部署在专用的服务器上</h3>
<h3>2.3 分片查询</h3>
<p>x是片键，根据x的值可以很容易地找到所属的分片</p>
<img src="https://img.feihu1996.cn/分片查询.png" alt="">
<img src="https://img.feihu1996.cn/分片查询1.png" alt="">
<p>y不是片键，根据y的值不是很容易地找到所属的分片</p>
<p>此时mongos会将请求转发给所有可能包含对应文档的分片，每个分片内部独立执行查询并返回复合查询条件的文档</p>
<img src="https://img.feihu1996.cn/分片查询2.png" alt="">
<p>mongos会将各个分片的返回值组合在一起返回给客户端</p>
<img src="https://img.feihu1996.cn/分片查询3.png" alt="">
<p>效率较低</p>
<h2>3、两个及以上的分片服务器</h2>
<h3>3.1 主分片</h3>
<ul>
<li>集群中的每个数据库都会选择一个分片作为主分片</li>
<li>保存数据库当中不需要使用分片的集合</li>
<li>创建数据库时，数据最少的分片会被选为主分片</li>
<li>主分片可以改变，但是成本很高</li>
</ul>
<h3>3.2 普通分片</h3>
<h1>四、分片片键</h1>
<h2>1、决定集合中的文档应当分布到哪些分片</h2>
<h2>2、可以选择一个或多个字段作为分片片键</h2>
<h2>3、片键值被用来将集合中的文档划分为不同的数据段</h2>
<h2>4、片键必须对应一个索引或索引前缀（单键或复合键）</h2>
<h2>5、可以使用片键值的哈希值来生成哈希片键</h2>
<img src="https://img.feihu1996.cn/分片片键.png" alt="">
<ul>
<li>使用x作为分片片键</li>
<li>根据x字段值的取值范围划分出若干数据段</li>
<li>数据段归属于不同的分片</li>
</ul>
<img src="https://img.feihu1996.cn/分片片键1.png" alt="">
<ul>
<li>使用x作为分片片键</li>
<li>根据x字段值的哈希值的取值范围划分出若干数据段</li>
<li>数据段归属于不同的分片</li>
</ul>
<h2>6、选择片键</h2>
<h3>6.1 片键值的范围更广</h3>
<p>可使用复合片键扩大范围</p>
<h3>6.2 片键值的分布更平衡</h3>
<p>可使用复合片键平衡分布</p>
<h3>6.3 片键值不要单向增大/减小</h3>
<p>可使用哈希片键</p>
<h3>6.4 片键选定后不可更改</h3>
<h1>五、动态的平衡</h1>
<h2>1、数据段的分裂</h2>
<h3>1.1 其实是一个动态的过程</h3>
<h3>1.2 随着不断收到客户的请求以及数据库中文档数量不停的变化，相应的数据段中的文档数量也是在不停的变化着的</h3>
<h3>1.3 当某个数据段尺寸过大或者包含过多文档时，MongoDB会将这个大数据段分裂成若干个较小的数据段</h3>
<h3>1.4 只有新增/更新文档时才可能自动触发数据段分裂</h3>
<h3>1.5 数据段分裂通过更新元数据来实现</h3>
<h2>2、集群的平衡</h2>
<h3>2.1 后台运行的平衡器进程负责监视和调整集群的平衡</h3>
<h3>2.2 当最大和最小分片之间的数据段数量相差过大时，平衡器会将最大分片中部分数据段迁移给最小分片</h3>
<p>差值可以配置</p>
<h3>2.3 集群中添加或移除分片时也会触发</h3>
log_PostTime: 1587567738
log_CommNums: 0
log_ViewNums: 23
log_Template: 
    log_Meta: 
1 row in set (0.00 sec)

ERROR: 
No query specified